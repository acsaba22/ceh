* Nix szeretok cehe
+ Közös megállapodások és repositoryk a linuxos fejlesztői környezeteinkről.
+ Hogy könnyű legyen mindenkinél működő programokat írni.
  - Pl. haskell header lehessen `#!/opt/ceh/bin/runhaskell' bonyolítás helyett.
+ Hogyha a hasznos csomagok mindenkinél fel legyenek telepítve.
  - Pl. ghc.
+ A megállapodások szándékosan minél egyszerűbb unifikációra
  törekszenek, nem absztrakcióra.
+ nix-et használunk package managementre, mert úgy tűnik, hogy meg
  lehet vele oldani egyszerűen bináris csomagok pontos repródukálását
  vegyes linuxok között.
+ a nix-ünk i686 és azt ajánljuk, hogy a gépeinken is i686 legyen a
  debian.  Ez nem követelmény és továbbá ajánlott az i686 debiant
  amd64 kernellel használni (ami tökéletesen működik), hogy lehetővé
  váljon esetenként amd64 kódok futtatása, ha a performance igényli.


* Requirements
+ Valamilyen értelmes linux (gubuntu, debian, ubuntu).
+ Intel architektúra (i686 vagy amd64, no arm please).
+ `sudo parancs' rootként futtat parancsot (tehát debianosoknak
  telepíteni kell a sudo-t).
+ A nix elboldoguljon az NSS-sel.  Azaz no libnss_cache és no
  libnss_ldap.  A googlen belül az egyszerű workaround:
    cat /etc/passwd.cache | grep "^$USER:" | sudo tee -a /etc/passwd


* Inicializálás
sudo mkdir /opt/ceh
sudo chown $USER. /opt/ceh
chmod 0700 /opt/ceh
cd /opt/ceh
git clone git://github.com/errge/ceh.git .
#  (if you want to contribute and you have a github user: git@github.com:errge/ceh.git)
ln -s $HOME home


* Nix telepítés
/opt/ceh/scripts/nix-init.sh


* Nix használat
Az /opt/ceh/bin/-ben kis wrapper scriptek vannak, amik ha valami még
nincs feltelepítve, amit a user elindított, akkor feltelepítik.  Tehát
nincs semmi tennivaló, amennyiben a PATH-ben benne van az
/opt/ceh/bin/, akkor onnan ezeken a kis wrappereken keresztül a
programoknak működniük kell.


* Haskell csomagok forditasa cabal-lal
Van a nix-nek technologiaja a ghc meghackelesere, hogy a cabal
csomagokat is o kezelje, de ehhez karbantartanak config fileokat, amik
a cabal csomagokat irjak le egyesevel.  Ez azt jelenti, hogy
laggolnank a hackagehez kepest es plusz bonyolitasokat kellene
felvallalnunk.  Az ut, amit megprobalunk az inkabb az, hogy a cabal-t
onmagaban hasznaljuk haskell libek feltelepitesehez, nem a nix-en
keresztul.  A nix csupan a haskell libek leforditasahoz szukseges c
libeket fogja adni.

Eloszor allitsuk be, hogy kerunk library profiling-ot:
  cabal update
  vi ~/.cabal/config (es engedelyezni a library-profiling-ot)

Mivel a nix (i386) architekturaja elterhet a gep (amd64)
architekturajatol, az egesz toolchainbol a nix-et akarjuk hasznalni,
nem csak ghc-bol.  Tehat ld, gcc, g++, minden.  Ezt erik el a
/opt/ceh/bin-ben levo kis wrapper scriptek, ami cabal, ghci, ghc,
stb. futtatasa eseten megmachinaljak a PATH-t, CFLAGS-t, LDFLAGS-t oly
modon, hogy ne a distrib binutils-a legyen hasznalva, hanem a nix-e.
Valamint ezek a wrapperek azt is elintezik, hogy a clibeket a FFI
libraryk a /nix/var/nix/profiles/ceh/ghc-libs/ prefix alatt keressek.

Ez azt jelenti, hogy egyszeru, FFI mentes haskell csomagok telepitese
egyszeruen out-of-the-box mukodik (cabal install whatever).

FFI csomagok eseten termeszetesen szukseges elotte feltelpiteni a
ceh/ghc-libs nix profileba a "-dev csomagokat", pl.:
  ceh_nix_install_for_ghc /nix/store/9pn5796z6nz827inhq560zdispvkpzr8-openssl-1.0.0i


* TODO-k
** README.org formazas githubbal
Kitalalni, hogy hogyan kell org mode-ot es github readmet egyutt
hasznalni, hogy a formazasa a kod szegmenseknek <pre> legyen...

** /usr/lib/mozilla/plugins elrejtese LD_PRELOAD-dal a firefox elol

** exclusion mechanizmus /opt/ceh/bin-user, ceh_exclude script
